--- sv210_wm8960.c	2014-06-30 15:49:40.000000000 +0900
+++ sv210_alc5622.c	2014-06-30 15:49:40.000000000 +0900
@@ -1,5 +1,5 @@
 /*
- *  sv210_wm8960.c
+ *  smdk64xx_wm8580.c
  *
  *  Copyright (c) 2009 Samsung Electronics Co. Ltd
  *  Author: Jaswinder Singh <jassi.brar@samsung.com>
@@ -9,6 +9,10 @@
  *  Free Software Foundation;  either version 2 of the  License, or (at your
  *  option) any later version.
  */
+/*
+ * sv210_rt5621.c
+ * ALC5622 - SV210  
+ */
 
 #include <linux/platform_device.h>
 #include <linux/clk.h>
@@ -17,67 +21,94 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
-#include <mach/regs-clock.h>
-#include <plat/regs-iis.h>
-#include "../codecs/wm8960.h"
+
+#include "../codecs/alc5622.h"
 #include "s3c-dma.h"
-//#include "s5pc1xx-i2s.h"
-#include "s3c-i2s-v2.h"
 #include "s3c64xx-i2s.h"
 
 #include <linux/io.h>
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+
 #include <asm/io.h>
 #include <asm/gpio.h>
 #include <plat/gpio-cfg.h>
 #include <plat/map-base.h>
 #include <linux/irq.h>
 
-#define I2S_NUM 0
-#define SRC_CLK 66738000
+//GPH3_6
+#define IRQ_HPJACK          IRQ_EINT(30) //EINT30
+#define GPIO_HPJACK         S5PV210_GPH3(6)
+#define GPIO_HPJACK_NAME    "GPH3_6"
 
-extern struct snd_soc_platform s3c_dma_wrapper;
-static struct platform_device *sv210_snd_device;
+static struct delayed_work dwork_ear_detect;
+u8      g_current_out;
+bool    g_btvout;
+bool    irq_type;
 
-/* #define CONFIG_SND_DEBUG */
-#ifdef CONFIG_SND_DEBUG
-#define debug_msg(x...) printk(x)
-#else
-#define debug_msg(x...)
-#endif
+extern bool get_hdmi_onoff_status(void);
 
-static int set_epll_rate(unsigned long rate)
+
+int sv210_hpjack_detect(struct delayed_work *dwork)
 {
-	struct clk *fout_epll;
+    int err;
 
-	fout_epll = clk_get(NULL, "fout_epll");
-	if (IS_ERR(fout_epll)) {
-		printk(KERN_ERR "%s: failed to get fout_epll\n", __func__);
-		return -ENOENT;
-	}
+    if (gpio_is_valid(GPIO_HPJACK))
+    {
+        err = gpio_request(GPIO_HPJACK, GPIO_HPJACK_NAME);
+        if(err) return err;
+
+        if(gpio_get_value(GPIO_HPJACK) && (g_current_out!=RT5621_SPK))
+		{
+            g_current_out=RT5621_SPK;
+		}
+        else if(!gpio_get_value(GPIO_HPJACK) && (g_current_out!=RT5621_HP))
+		{
+            g_current_out=RT5621_HP;
+		}
+        gpio_free(GPIO_HPJACK);
+    }
+
+    if(!g_btvout)
+    {
+        rt5621_set_outpath(g_current_out);
+    }
+//    enable_irq(IRQ_HPJACK);
+    return err;
+}
 
-	if (rate == clk_get_rate(fout_epll))
-		goto out;
+void sv210_audio_tvout(bool tvout)
+{
+    u8 temp;
 
-	clk_disable(fout_epll);
-	clk_set_rate(fout_epll, rate);
-	clk_enable(fout_epll);
+    if(tvout) {
+        g_btvout = true;
+        temp = RT5621_NONE;
+    }
+    else {
+        g_btvout = false;
+        temp = g_current_out;
+    }
+    rt5621_set_outpath(temp);
+}
+EXPORT_SYMBOL(sv210_audio_tvout);
 
-out:
-	clk_put(fout_epll);
+#define I2S_NUM 0
 
-	return 0;
-}
+extern struct snd_soc_dai i2s_sec_fifo_dai;
+extern struct snd_soc_platform s3c_dma_wrapper;
+extern const struct snd_kcontrol_new s5p_idma_control;
+
+static int set_epll_rate(unsigned long rate);
 
-/*  BLC(bits-per-channel) --> BFS(bit clock shud be >= FS*(Bit-per-channel)*2)*/
-/*  BFS --> RFS(must be a multiple of BFS)                                  */
-/*  RFS & SRC_CLK --> Prescalar Value(SRC_CLK / RFS_VAL / fs - 1)           */
-static int sv210_hw_params(struct snd_pcm_substream *substream,
+static int smdk64xx_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-	unsigned int rclk, psr = 1;
+	unsigned int rclk, psr=1;
 	int bfs, rfs, ret;
+	unsigned long epll_out_rate;
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_U24:
@@ -156,11 +187,16 @@
 		psr = 1;
 		break;
 	default:
-		printk(KERN_ERR "Not yet supported!\n");
+		printk("Not yet supported!\n");
 		return -EINVAL;
 	}
 
-	set_epll_rate(rclk * psr);
+	epll_out_rate = rclk * psr;
+
+	/* Set EPLL clock rate */
+	ret = set_epll_rate(epll_out_rate);
+	if (ret < 0)
+		return ret;
 
 	ret = snd_soc_dai_set_sysclk(cpu_dai, S3C64XX_CLKSRC_CDCLK,
 					0, SND_SOC_CLOCK_OUT);
@@ -189,46 +225,57 @@
 }
 
 /*
- * SV210 WM8960 DAI operations.
+ * SMDK64XX WM8580 DAI operations.
  */
-static struct snd_soc_ops sv210_ops = {
-	.hw_params = sv210_hw_params,
+static struct snd_soc_ops smdk64xx_ops = {
+	.hw_params = smdk64xx_hw_params,
 };
 
-/* SV210 Playback widgets */
-static const struct snd_soc_dapm_widget wm8960_dapm_widgets_pbk[] = {
-	SND_SOC_DAPM_HP("Speaker-L/R", NULL),
-	SND_SOC_DAPM_HP("HP-L/R", NULL),
+/* SMDK64xx Playback widgets */
+static const struct snd_soc_dapm_widget wm8580_dapm_widgets_pbk[] = {
+	SND_SOC_DAPM_HP("Front-L/R", NULL),
+	SND_SOC_DAPM_HP("Center/Sub", NULL),
+	SND_SOC_DAPM_HP("Rear-L/R", NULL),
 };
 
-/* SV210 Capture widgets */
-static const struct snd_soc_dapm_widget wm8960_dapm_widgets_cpt[] = {
+/* SMDK64xx Capture widgets */
+static const struct snd_soc_dapm_widget wm8580_dapm_widgets_cpt[] = {
 	SND_SOC_DAPM_MIC("MicIn", NULL),
+	SND_SOC_DAPM_LINE("LineIn", NULL),
 };
 
 /* SMDK-PAIFTX connections */
 static const struct snd_soc_dapm_route audio_map_tx[] = {
-	/* MicIn feeds LINPUT1 */
-	{"LINPUT1", NULL, "MicIn"},
+	/* MicIn feeds AINL */
+	{"AINL", NULL, "MicIn"},
+
+	/* LineIn feeds AINL/R */
+	{"AINL", NULL, "LineIn"},
+	{"AINR", NULL, "LineIn"},
 };
 
 /* SMDK-PAIFRX connections */
 static const struct snd_soc_dapm_route audio_map_rx[] = {
-	{"Speaker-L/R", NULL, "SPK_LP"},
-	{"Speaker-L/R", NULL, "SPK_LN"},
-	{"Speaker-L/R", NULL, "SPK_RP"},
-	{"Speaker-L/R", NULL, "SPK_RN"},
-	{"HP-L/R", NULL, "HP_L"},
-	{"HP-L/R", NULL, "HP_R"},
+	/* Front Left/Right are fed VOUT1L/R */
+	{"Front-L/R", NULL, "VOUT1L"},
+	{"Front-L/R", NULL, "VOUT1R"},
+
+	/* Center/Sub are fed VOUT2L/R */
+	{"Center/Sub", NULL, "VOUT2L"},
+	{"Center/Sub", NULL, "VOUT2R"},
+
+	/* Rear Left/Right are fed VOUT3L/R */
+	{"Rear-L/R", NULL, "VOUT3L"},
+	{"Rear-L/R", NULL, "VOUT3R"},
 };
 
-static int sv210_wm8960_init_paiftx(struct snd_soc_codec *codec)
+static int smdk64xx_wm8580_init_paiftx(struct snd_soc_codec *codec)
 {
 	int ret;
 
-	/* Add sv210 specific Capture widgets */
-	snd_soc_dapm_new_controls(codec, wm8960_dapm_widgets_cpt,
-				  ARRAY_SIZE(wm8960_dapm_widgets_cpt));
+	/* Add smdk64xx specific Capture widgets */
+	snd_soc_dapm_new_controls(codec, wm8580_dapm_widgets_cpt,
+				  ARRAY_SIZE(wm8580_dapm_widgets_cpt));
 
 	/* Set up PAIFTX audio path */
 	snd_soc_dapm_add_routes(codec, audio_map_tx, ARRAY_SIZE(audio_map_tx));
@@ -236,47 +283,51 @@
 	/* Enabling the microphone requires the fitting of a 0R
 	 * resistor to connect the line from the microphone jack.
 	 */
-//	snd_soc_dapm_disable_pin(codec, "MicIn");
+	snd_soc_dapm_disable_pin(codec, "MicIn");
 
 	/* signal a DAPM event */
 	snd_soc_dapm_sync(codec);
 
 	/* Set the Codec DAI configuration */
-	ret = snd_soc_dai_set_fmt(&wm8960_dai, SND_SOC_DAIFMT_I2S
+	ret = snd_soc_dai_set_fmt(&wm8580_dai[WM8580_DAI_PAIFTX], SND_SOC_DAIFMT_I2S
 					 | SND_SOC_DAIFMT_NB_NF
 					 | SND_SOC_DAIFMT_CBS_CFS);
 	if (ret < 0)
 		return ret;
-
-	// Set the AP DAI configuration 
+	/* Set the AP DAI configuration */
 	ret = snd_soc_dai_set_fmt(&s3c64xx_i2s_dai[I2S_NUM], SND_SOC_DAIFMT_I2S
 					 | SND_SOC_DAIFMT_NB_NF
 					 | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
 
+	/* Set WM8580 to drive MCLK from its MCLK-pin */
+	ret = snd_soc_dai_set_clkdiv(&wm8580_dai[WM8580_DAI_PAIFTX], WM8580_MCLK,
+					WM8580_CLKSRC_MCLK);
 	if (ret < 0)
 		return ret;
 
-	/* Set WM8960 to drive MCLK from its MCLK-pin */
-	ret = snd_soc_dai_set_clkdiv(&wm8960_dai, WM8960_SYSCLKSEL,
-					WM8960_SYSCLK_MCLK);
+	/* Explicitly set WM8580-ADC to source from MCLK */
+	ret = snd_soc_dai_set_clkdiv(&wm8580_dai[WM8580_DAI_PAIFTX], WM8580_ADC_CLKSEL,
+					WM8580_CLKSRC_MCLK);
 	if (ret < 0)
 		return ret;
 
 	return 0;
 }
 
-static int sv210_wm8960_init_paifrx(struct snd_soc_codec *codec)
+static int smdk64xx_wm8580_init_paifrx(struct snd_soc_codec *codec)
 {
 	int ret;
 
-	/* Add sv210 specific Playback widgets */
-	snd_soc_dapm_new_controls(codec, wm8960_dapm_widgets_pbk,
-				  ARRAY_SIZE(wm8960_dapm_widgets_pbk));
+	/* Add smdk64xx specific Playback widgets */
+	snd_soc_dapm_new_controls(codec, wm8580_dapm_widgets_pbk,
+				  ARRAY_SIZE(wm8580_dapm_widgets_pbk));
 
 	/* add iDMA controls */
-//	ret = snd_soc_add_controls(codec, &s5p_idma_control, 1);
-//	if (ret < 0)
-//		return ret;
+	ret = snd_soc_add_controls(codec, &s5p_idma_control, 1);
+	if (ret < 0)
+		return ret;
 
 	/* Set up PAIFRX audio path */
 	snd_soc_dapm_add_routes(codec, audio_map_rx, ARRAY_SIZE(audio_map_rx));
@@ -284,17 +335,10 @@
 	/* signal a DAPM event */
 	snd_soc_dapm_sync(codec);
 
-	// Set the Codec DAI configuration 
-	ret = snd_soc_dai_set_fmt(&wm8960_dai, SND_SOC_DAIFMT_I2S
+	/* Set the Codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(&wm8580_dai[WM8580_DAI_PAIFRX], SND_SOC_DAIFMT_I2S
 					 | SND_SOC_DAIFMT_NB_NF
 					 | SND_SOC_DAIFMT_CBS_CFS);
-
-    /* Set the AP DAI configuration */
-    ret = snd_soc_dai_set_fmt(&s3c64xx_i2s_dai[S3C24XX_DAI_I2S],
-                    SND_SOC_DAIFMT_I2S
-                     | SND_SOC_DAIFMT_NB_NF
-                     | SND_SOC_DAIFMT_CBS_CFS);
-
 	if (ret < 0)
 		return ret;
 
@@ -305,119 +349,189 @@
 	if (ret < 0)
 		return ret;
 
-	/* Set WM8960 to drive MCLK from its MCLK-pin */
-	ret = snd_soc_dai_set_clkdiv(&wm8960_dai, WM8960_SYSCLKSEL,
-					WM8960_SYSCLK_MCLK);
+	/* Set WM8580 to drive MCLK from its MCLK-pin */
+	ret = snd_soc_dai_set_clkdiv(&wm8580_dai[WM8580_DAI_PAIFRX], WM8580_MCLK,
+					WM8580_CLKSRC_MCLK);
+	if (ret < 0)
+		return ret;
 
+	/* Explicitly set WM8580-DAC to source from MCLK */
+	ret = snd_soc_dai_set_clkdiv(&wm8580_dai[WM8580_DAI_PAIFRX], WM8580_DAC_CLKSEL,
+					WM8580_CLKSRC_MCLK);
 	if (ret < 0)
 		return ret;
 
 	return 0;
 }
 
-static struct snd_soc_dai_link sv210_dai[] = {
+static struct snd_soc_dai_link smdk64xx_dai[] = {
 { /* Primary Playback i/f */
-	.name = "WM8960 PAIF RX",
+	.name = "WM8580 PAIF RX",
 	.stream_name = "Playback",
-//	.cpu_dai = &s3c64xx_i2s_v4_dai[S3C24XX_DAI_I2S],
 	.cpu_dai = &s3c64xx_i2s_dai[I2S_NUM],
-	.codec_dai = &wm8960_dai,
-	.init = sv210_wm8960_init_paifrx,
-	.ops = &sv210_ops,
+	.codec_dai = &wm8580_dai[WM8580_DAI_PAIFRX],
+	.init = smdk64xx_wm8580_init_paifrx,
+	.ops = &smdk64xx_ops,
 },
 { /* Primary Capture i/f */
-	.name = "WM8960 PAIF TX",
+	.name = "WM8580 PAIF TX",
 	.stream_name = "Capture",
-//	.cpu_dai = &s3c64xx_i2s_v4_dai[S3C24XX_DAI_I2S],
 	.cpu_dai = &s3c64xx_i2s_dai[I2S_NUM],
-	.codec_dai = &wm8960_dai,
-	.init = sv210_wm8960_init_paiftx,
-	.ops = &sv210_ops,
+	.codec_dai = &wm8580_dai[WM8580_DAI_PAIFTX],
+	.init = smdk64xx_wm8580_init_paiftx,
+	.ops = &smdk64xx_ops,
 },
+/*{
+	.name = "WM8580 PAIF RX",
+	.stream_name = "Playback-Sec",
+	.cpu_dai = &i2s_sec_fifo_dai,
+	.codec_dai = &wm8580_dai[WM8580_DAI_PAIFRX],
+},*/
 };
 
-static struct snd_soc_card sv210 = {
-	.name = "H-SV210 Platform",
+static struct snd_soc_card smdk64xx = {
+	.name = "V210_DK",
 	.platform = &s3c_dma_wrapper,
-	.dai_link = sv210_dai,
-	.num_links = ARRAY_SIZE(sv210_dai),
+	.dai_link = smdk64xx_dai,
+	.num_links = ARRAY_SIZE(smdk64xx_dai),
 };
 
-static struct snd_soc_device sv210_snd_devdata = {
-	.card = &sv210,
-	.codec_dev = &soc_codec_dev_wm8960,
+static struct snd_soc_device smdk64xx_snd_devdata = {
+	.card = &smdk64xx,
+	.codec_dev = &soc_codec_dev_wm8580,
 };
 
-static int __init sv210_audio_init(void)
+static struct platform_device *smdk64xx_snd_device;
+
+static int set_epll_rate(unsigned long rate)
 {
-    int ret, err;
-    u32 val, reg;
+	struct clk *fout_epll;
+
+	fout_epll = clk_get(NULL, "fout_epll");
+	if (IS_ERR(fout_epll)) {
+		printk(KERN_ERR "%s: failed to get fout_epll\n", __func__);
+		return -ENOENT;
+	}
+
+	if (rate == clk_get_rate(fout_epll))
+		goto out;
+
+	clk_disable(fout_epll);
+	clk_set_rate(fout_epll, rate);
+	clk_enable(fout_epll);
+
+out:
+	clk_put(fout_epll);
+
+	return 0;
+}
+
+static int __init smdk64xx_audio_init(void)
+{
+	int ret;
+	u32 val;
+	u32 reg;
+    int err;
+
 #include <mach/map.h>
-#define S3C_VA_AUDSS    S3C_ADDR(0x01600000)    /* Audio SubSystem */
+#define S3C_VA_AUDSS	S3C_ADDR(0x01600000)	/* Audio SubSystem */
 #include <mach/regs-audss.h>
-#include <mach/regs-clock.h>
-#define S5P_CLKOUT_CLKSEL_SHIFT         (12)
-#define S5P_CLKOUT_CLKSEL_MASK          (0x1f << S5P_CLKOUT_CLKSEL_SHIFT)
-#define S5P_CLKOUT_CLKSEL_XUSBXTI       (18 << S5P_CLKOUT_CLKSEL_SHIFT)
-    
-#define S5P_CLKOUT_DIV_SHIFT            (20)
-#define S5P_CLKOUT_DIV_MASK             (0xf << S5P_CLKOUT_DIV_SHIFT)
-
-    /* We use I2SCLK for rate generation, so set EPLLout as
-     * the parent of I2SCLK.
-     */
-    val = readl(S5P_CLKSRC_AUDSS);
-    val &= ~(0x3<<2);
-    val |= (1<<0);
-    writel(val, S5P_CLKSRC_AUDSS);
-
-    val = readl(S5P_CLKGATE_AUDSS);
-    val |= (0x7f<<0);
-    writel(val, S5P_CLKGATE_AUDSS);
+	/* We use I2SCLK for rate generation, so set EPLLout as
+	 * the parent of I2SCLK.
+	 */
+	val = readl(S5P_CLKSRC_AUDSS);
+	val &= ~(0x3<<2);
+	val |= (1<<0);
+	writel(val, S5P_CLKSRC_AUDSS);
+
+	val = readl(S5P_CLKGATE_AUDSS);
+	val |= (0x7f<<0);
+	writel(val, S5P_CLKGATE_AUDSS);
 
 #ifdef CONFIG_S5P_LPAUDIO
-    /* yman.seo CLKOUT is prior to CLK_OUT of SYSCON. XXTI & XUSBXTI work in sleep mode */
-    reg = __raw_readl(S5P_OTHERS);
-    reg &= ~(0x0003 << 8);
-    reg |= 0x0003 << 8; /* XUSBXTI */
-    __raw_writel(reg, S5P_OTHERS);
+	/* yman.seo CLKOUT is prior to CLK_OUT of SYSCON. XXTI & XUSBXTI work in sleep mode */
+	reg = __raw_readl(S5P_OTHERS);
+	reg &= ~(0x0003 << 8);
+	reg |= 0x0003 << 8;	/* XUSBXTI */
+	__raw_writel(reg, S5P_OTHERS);
 #else
-    /* yman.seo Set XCLK_OUT as 24MHz (XUSBXTI -> 24MHz) */
-    reg = __raw_readl(S5P_CLK_OUT);
-    reg &= ~S5P_CLKOUT_CLKSEL_MASK;
-    reg |= S5P_CLKOUT_CLKSEL_XUSBXTI;
-    reg &= ~S5P_CLKOUT_DIV_MASK;
-    reg |= 0x0001 << S5P_CLKOUT_DIV_SHIFT;  /* DIVVAL = 1, Ratio = 2 = DIVVAL + 1 */
-    __raw_writel(reg, S5P_CLK_OUT);
-
-    reg = __raw_readl(S5P_OTHERS);
-    reg &= ~(0x0003 << 8);
-    reg |= 0x0000 << 8; /* Clock from SYSCON */
-    __raw_writel(reg, S5P_OTHERS);
+	/* yman.seo Set XCLK_OUT as 24MHz (XUSBXTI -> 24MHz) */
+	reg = __raw_readl(S5P_CLK_OUT);
+	reg &= ~S5P_CLKOUT_CLKSEL_MASK;
+	reg |= S5P_CLKOUT_CLKSEL_XUSBXTI;
+	reg &= ~S5P_CLKOUT_DIV_MASK;
+	reg |= 0x0001 << S5P_CLKOUT_DIV_SHIFT;	/* DIVVAL = 1, Ratio = 2 = DIVVAL + 1 */
+	__raw_writel(reg, S5P_CLK_OUT);
+
+	reg = __raw_readl(S5P_OTHERS);
+	reg &= ~(0x0003 << 8);
+	reg |= 0x0000 << 8;	/* Clock from SYSCON */
+	__raw_writel(reg, S5P_OTHERS);
 #endif
 
-	sv210_snd_device = platform_device_alloc("soc-audio", 0);
-	if (!sv210_snd_device)
+	smdk64xx_snd_device = platform_device_alloc("soc-audio", 0);
+	if (!smdk64xx_snd_device)
 		return -ENOMEM;
 
-	platform_set_drvdata(sv210_snd_device, &sv210_snd_devdata);
-	sv210_snd_devdata.dev = &sv210_snd_device->dev;
-	ret = platform_device_add(sv210_snd_device);
+	platform_set_drvdata(smdk64xx_snd_device, &smdk64xx_snd_devdata);
+	smdk64xx_snd_devdata.dev = &smdk64xx_snd_device->dev;
+	ret = platform_device_add(smdk64xx_snd_device);
 
 	if (ret)
-		platform_device_put(sv210_snd_device);
+		platform_device_put(smdk64xx_snd_device);
 
-	return ret;
-}
+#if 0
+    /* Setup Default Route */
+    g_current_out = RT5621_NONE;
+
+    if (gpio_is_valid(GPIO_HPJACK))
+    {
+        err = gpio_request(GPIO_HPJACK, GPIO_HPJACK_NAME);
+        if(err)
+        {
+            printk(KERN_ERR "failed to request HPJACK for RT5621\n");
+            return err;
+        }
+        gpio_direction_input(GPIO_HPJACK);
+        s3c_gpio_setpull(GPIO_HPJACK, S3C_GPIO_PULL_DOWN);
+
+        if(gpio_get_value(GPIO_HPJACK))
+		{
+			g_current_out=RT5621_SPK;
+		}
+        else
+		{
+			g_current_out=RT5621_HP;
+		}
+
+        gpio_free(GPIO_HPJACK);
+    }
+
+    err = request_irq(IRQ_HPJACK, sv210_hpjack_isr, \
+			IRQF_SAMPLE_RANDOM | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, "hpjack-irq", NULL);
+
+    if(err) printk("DEBUG -> IRQ_HPJACK request error!!!\n");
+
+    INIT_DELAYED_WORK(&dwork_ear_detect, sv210_hpjack_detect);
+
+#if 0
+    if(get_hdmi_onoff_status()) {
+        g_btvout = true;
+        rt5621_set_outpath(RT5621_NONE);
+    } else {
+        g_btvout = false;
+        rt5621_set_outpath(g_current_out);
+    }
+#endif
+#endif
 
-static void __exit sv210_audio_exit(void)
-{
-	debug_msg("%s\n", __func__);
+	g_btvout = false;
+	g_current_out=RT5621_SPK;
+    rt5621_set_outpath(g_current_out);
 
-	platform_device_unregister(sv210_snd_device);
+	return ret;
 }
-module_init(sv210_audio_init);
-module_exit(sv210_audio_exit);
+module_init(smdk64xx_audio_init);
 
 MODULE_AUTHOR("Jaswinder Singh, jassi.brar@samsung.com");
 MODULE_DESCRIPTION("ALSA SoC SMDK64XX WM8580");
